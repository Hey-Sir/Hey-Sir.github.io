{"meta":{"title":"很拽的小鲁班","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"关于HTTP协议，一篇就够了","slug":"关于HTTP协议，一篇就够了","date":"2020-09-06T06:38:46.000Z","updated":"2020-09-06T08:01:36.036Z","comments":true,"path":"2020/09/06/关于HTTP协议，一篇就够了/","link":"","permalink":"http://example.com/2020/09/06/%E5%85%B3%E4%BA%8EHTTP%E5%8D%8F%E8%AE%AE%EF%BC%8C%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/","excerpt":"一、HTTP 简介 1、http协议，超文本传输协议（hypertext transfer protocol），是一种详细规定了浏览器和万维网服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议","text":"一、HTTP 简介 1、http协议，超文本传输协议（hypertext transfer protocol），是一种详细规定了浏览器和万维网服务器之间互相通信的规则，通过因特网传送万维网文档的数据传送协议 2、HTTP协议通常承载于TCP协议之上，有时也承载与TLS/SSL协议层之上，这个时候，就成了我们常说的HTTPS 如下图 3、HTTP 是一个应用层协议，由请求和享用构成，是一个标准的客服端服务器模型。http是一个无状态的协议 4、http 默认端口 80，https 默认是443 二、HTTP 状态码 状态码由三位数字组成，第一位数字定义了响应的类别，分五种类别 1XX : 指示信息– 表示请求已接收，继续处理 2xx : 成功– 表示请求已经被成功接收、理解、接收 3xx：重定向–要完成请求必须进行更进一步的操作 4xx：客户端错误–请求有语法错误或请求无法实现 5xx：服务器端错误–服务器未能实现合法的请求 常见状态码 三 HTTP 请求方法 http1.0 get post head http1.1 get post put delete options trace connect 1、简单快速","categories":[],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://example.com/tags/HTTP/"},{"name":"协议","slug":"协议","permalink":"http://example.com/tags/%E5%8D%8F%E8%AE%AE/"},{"name":"网络传输","slug":"网络传输","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93/"}]},{"title":"JAVA基础面试题","slug":"JAVA基础面试题","date":"2019-09-11T09:35:35.000Z","updated":"2020-09-06T06:28:50.825Z","comments":true,"path":"2019/09/11/JAVA基础面试题/","link":"","permalink":"http://example.com/2019/09/11/JAVA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"1、异常的分类 throwable 分为 error 和 exception error 错误有jvm处理 exception 分为运行时异常 和 非运行时异常 运行时异常 比如 int a = 1/0 非运行时异常必须去捕获 或者继续跑出","text":"1、异常的分类 throwable 分为 error 和 exception error 错误有jvm处理 exception 分为运行时异常 和 非运行时异常 运行时异常 比如 int a = 1/0 非运行时异常必须去捕获 或者继续跑出 2、String StringBuffer StringBuilder 之间的区别String 是不可变的，每次对Sting 操作都会生成新的String 对象。开辟新的内存对象 String 为什么是不可变的，通过查看源码，简单来说就是String类利用了final修饰的char类型数组存储字符 private final char value[] ；保存字符串 所以String 对象是不可变的 StringBuffer 可变字符串 效率低，线程安全 通过查看源码可知 由synchronized 修饰的 123456789@Overridepublic synchronized StringBuffer append(String str) &#123;toStringCache &#x3D; null; super.append(str);return this;&#125; Stringbuilder 不可变字符串 效率高线程不安全 3、线程 参考:https://www.cnblogs.com/happy-coder/p/6587092.html 线程状态 1、新建状态 （new） ：线程对象被创建后，就进入新建状态 Thread thread = new Thread(); 2、就绪状态 （runable） 调用了该对象的start() 方法 从而启动线程 例如 thread.start() 处于就绪状态，随时可能被cpu调度执行 3、运行状态（running） 线程获得cpu 的执行权限，线程只能从就绪进入运行状态 4、阻塞状态 阻塞状态是线程因为某种原因放弃cpu 的执行权限，暂时停止运行，直到线程进入就绪状态才有机会转到运行状态。阻塞的情况分为三种 5、死亡状态：线程执行完了或者因异常退出了 run() 方法，该线程结束生命周期 4、序列化和反序列化 序列化:把对象转成字节序列的过程称为序列化 反序列化:把字节序列恢复为对象的过程称为反序列化 用途: 把对象的字节序列永久的保存在硬盘上 通常是保存在一个文件中 把网络上传送对象的字节序列 5、基本类型和引用类型 基本数据类型 byte 8位 short 16位 int 32位 long 64位 float: 浮点型 32位 double 双精度浮点型 64位 char 字符型 16位 Boolean 布尔类型 1位 内存存储上的区别 基本数据类型 是直接存储在内存中的内存栈上 引用类型 使用内存堆和内存占进行存储，简单来说 引用 是存储在有序的内存栈上，而对象本身的值存储在内存堆上的 6、 ==与equals(重要)== 他的作用是判断两个对象的地址是不是相等，即，判断两个对象是不是同一个对象（基本数据类型==比较的是值，引用数据类型==比较的是内存地址） eques() ： 他的作用也是判断对象是否相等。蛋挞一般有两种使用情况: 情况1、类没有覆盖equals() 方法。则通过equals() 比较该类的两个对象时，等价于通过 “==” 比较这两个对象 情况2、类覆盖了equals() 方法。一般，我们都覆盖equals() 方法来两个对象的内容相等；若他们的内容相等，则返回true 举个例子 1234567891011121314151617181920212223242526272829303132public class test1 &#123; public static void main(String[] args) &#123; String a &#x3D; new String(&quot;ab&quot;); &#x2F;&#x2F; a 为一个引用 String b &#x3D; new String(&quot;ab&quot;); &#x2F;&#x2F; b为另一个引用,对象的内容一样 String aa &#x3D; &quot;ab&quot;; &#x2F;&#x2F; 放在常量池中 String bb &#x3D; &quot;ab&quot;; &#x2F;&#x2F; 从常量池中查找 if (aa &#x3D;&#x3D; bb) &#x2F;&#x2F; true System.out.println(&quot;aa&#x3D;&#x3D;bb&quot;); if (a &#x3D;&#x3D; b) &#x2F;&#x2F; false，非同一对象 System.out.println(&quot;a&#x3D;&#x3D;b&quot;); if (a.equals(b)) &#x2F;&#x2F; true System.out.println(&quot;aEQb&quot;); if (42 &#x3D;&#x3D; 42.0) &#123; &#x2F;&#x2F; true System.out.println(&quot;true&quot;); &#125;&#125;&#125; 上述运行结果 String 中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的值。 当创建String类型的对象是，虚拟机会在常量池查找有没有已经存在的值和要创建的值相同的对象。如果有就把它赋给当前引用，如果没有就在常量池中重新创建一个String对象 7、什么是反射机制？反射机制的应用场景有哪些？8、谈谈几种设计模式9、重载和重写的区别 重载: 在同一个类中，方法名必须相同，参数类型不同，个数不同，顺序不同，方法返回值和访问修饰符可以不同 重写: 发生在父子类中，方法名、参数列表必须相同，返回值返回小于父类，抛出的异常返回小于等于父类，访问修饰符范围大于等于父类。如果父类方法访问修饰符为private 则子类就不能够重写该方法 注意点: 父类的静态方法可以被继承，但不能被子类重写, 方法加静态后就属于类不属于对象了 10、接口和抽象类的区别抽象方法: 通过abstract修饰的方法，该方法只能生命没有具体的实现 格式 abstract void fun(); 抽象类: 如果一个类含有抽象方法，则该类为抽象类，类前必须用abstract 关键字修饰。因为抽象类中含有无具体实现的方法，所以不能用抽象类创建对象，但是一个类不包含抽象方法，也可以是抽象类，只要他用abstract关键字修饰了就是抽象类。 抽象类和普通类主要三点区别 抽象方法俺必须是public 或者protected （因为如果是private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public 抽象类不能创建对象 如果一个类继承了抽象类，则子类必须实现父类的抽象方法，如果子类没有实现父类的抽象方法，则必须将子类也定义为abstract类 接口: 接口可以含有变量和方法，但是注意：接口中的变量会被隐式的指定为public static final 变量（并且只能是public static final变量，用private修饰会报编译错误）而方法会被隐式的指定为public abstract 方法，而且只能是public abstract方法（用其他关键字，比如private、protected、static、 final等修饰会报编译错误），并且接口中的所有方法不能有具体的实现，也就是说，接口中的方法必须是抽象方法，从而可以看出，接口和抽象类的区别，接口是一种极度抽象的类型，他比抽象类更加“抽象类”，并且一般情况下不在接口中定义变量。可以看出，允许一个类遵循多个特定的接口。如果一个非抽象类遵循了某个接口，就必须实现该接口中的所有方法。对于遵循某个接口的抽象类，可以不实现该接口中的抽象方法。 二者的区别: 语法上: 一个类只能继承一个抽象类，而一个类可以实现多个接口 接口中不能含有静态代码块已经静态方法。而抽象类可以 抽象类中的成员变量可以是各种类型，而接口的成员变量只能是public static final类型的 抽象类可以提供成员方法的实现细节，而接口只能存在public abstract方法（抽象类可以有具体的方法实现，而接口是能都是抽象方法） 11、简单介绍下Java的面向对象https://www.cnblogs.com/hysum/p/7100874.html#_label1 三大特征: 封装 继承 多态 封装: 概念:将类的某些信息隐藏在类的内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问 继承: java 的继承是单继承，即一个类只能继承一个父类 多态: 引用多态: 父类的引用可以指向本类对象，父类的引用指向子类对象 方法多态: 创建本类对象时，调用的方法为本类的方法，创建子类对象时，调用的方法为子类重写的方法或者继承的方法。 多态存在的条件: 继承，重写 多态的作用是相处类型之间的耦合关系 在实践项目开发中，A类继承B类，如果在A类中不重写B类的方法的时候，输出的仍旧是B类方法里面的信息（B b = new A()）;如果在A类中重写B类的方法的时候， 输出的是A类放在里面的信息（B b = new A()) 注意：如果子类写有一个独有的方法（没有继承父类的方法），此时就不能通过父类的引用创建的子类对象来调用该方法。 12、servlet的生命周期 实例化servlet init()：servlet实例化时调用此方法 service(): 客户请求相应调用此方法 destroy(): 服务终止 13、jsp 的内置对象 jsp本质是一个servlet request对象 response对象 page对象 session对象 application对象 out对象 exception对象 config对象 pageContext对象 14、简单介绍下mvc model view controller 模型 试图 控制器 最经典的MVC 就是 jsp + servlet javabean model 数据模型，提供要展示的数据 view 负责进行模型的展示，一般是用户见到的用户界面 controller 控制器 接收用户请求 15、简单介绍下Tomcat16、jdbc的步骤 加载程序驱动 class,forname(“com.mysql.jdbc.driver”) 建立连接 需要用到drivermanager 类中静态方法getconnection（） 1Connection connection&#x3D;DriverManager.getConnection(&quot;jdbc:mysql:&#x2F;&#x2F;localhost&#x2F;Contacts?serverTimezone&#x3D;UTC&quot;, &quot;root&quot;, &quot;Cc229654512&quot;); 创建运行对象 运行对象statement 负责运行sql语句。有connection对象产生 1Statement st &#x3D; connection.createStatement(); 执行sql语句，可以使用方法executeUpdate(String sql) 来执行数据定义语言或者更新语句 可以使用executeQuery(String sql)来执行sql 查询语句。结果在resultset中返回 1ResultSet resultSet&#x3D;statement.executeQuery(&quot;select Name, PhoneNumber, Email, QQ, Note from Contacts&quot;); 处理resultset 结果集 resultset 可以获得表的当前行，可以使用nextt 方法移动行。可以使用get 方法获取当前行的值 1234567while(resultSet.next())&#123; System.out.println(resultSet.getString(1)+&quot;\\t&quot;+resultSet.getString(2)+&quot;\\t&quot;+resultSet.getString(3));&#125; 释放资源 17、java的反射机制概念: 在运行状态中，对于任意一个类，都能知道这个类的属性和方法，对于任意一个对象，都能调用他的方法和属性 反射的作用: 在运行时判断任意对象所属的类 在运行时判断任意对象所具有的的成员属性和方法 在运行时构造任意一个类的对象 18、volatile 关键字的作用synchronized 是属于重量级，volatile 是轻量级 保证共享变量对所有线程的可见性 1、当写一个volatile变量时，JMM会把该线程对应的本地内存中的变量强制刷新到主内存中去 2、这个写操作会导致其他线程中的缓存无效 禁止指令重排 19、java 创建线程池的几种方式 newScheduledThreadPool() 创建一个定长的线程池 支持定时及周期性任务执行 newCachedThreadPool 创建一个可缓存的线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程 newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待 newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序（FIFO,LIFO,优先级）执行 20、面向接口编程的优点 降低程序的耦合，最大限度的解耦，所谓的解耦，就是解耦合的意思 易于程序的扩展 有利于程序的维护 开闭原则：对扩展开放，对修改关闭 其恰恰就是遵循的是使用接口来实现。在使用面向接口的编程过程中，将具体逻辑与实现分开，减少各个类的相互依赖，当各个类变化时，不需要对已经编写的系统进程改动，添加新的实现类就可以了，不在担心新的改动的类会对系统的其他模块造成影响。 21、事务的实现方式 编程式事务 基于TransactionProxyFactoryBean的声明式事务管理 基于@transactional的声明式事务管理 基于AOP配置事务 事务的四种特性ACID atomic 原子性 consistency 一致性 isolation 隔离性 durability 持久性 22、mybatis 的 $ 和 # 的区别#{} 是预编译处理的 ${} 是字符串替换 mybatis在处理 #{} 时，会将sql中的 #{} 替换为 ？ 在 ${} 替换成变量的值 使用#{} 可以防止sqk注入 23、&amp; 和 &amp;&amp; 的区别 &amp; 两个判断条件都需要进行判断 而 &amp;&amp; 只要左边表达式为false 右边的表达式不会继续判断 整个表达式为false 24、float f = 3.4 是否正确 不正确 3.4浮点型默认是double 双精度类型的 定义为 float 属于向下转型，需要强转或者 写成 float f = 3.4f float f = 3.4F float f = (float)3.4; 补充 1 默认是 int 型 25、a = a + b 和 a+=b 的区别 26、冒泡算法 27、final, finally, finalize 的区别 final 用于声明 属性 方法 类 分别表示属性不可变，方法不可覆盖，类不可继承 finally 是异常处理语句结构的一部分，表示总是执行 finalize 是object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收。 28、int 和 Integer 区别 int 是基础数据类型，java为其提供封装类， int 默认值是0 integer是 null，是引用类型 29、说说自定义注解的场景及实现 未完待续…","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"},{"name":"基础","slug":"基础","permalink":"http://example.com/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"关于分布锁的多种实现方式","slug":"关于分布锁的多种实现方式","date":"2019-09-10T06:14:16.000Z","updated":"2020-09-06T06:28:15.179Z","comments":true,"path":"2019/09/10/关于分布锁的多种实现方式/","link":"","permalink":"http://example.com/2019/09/10/%E5%85%B3%E4%BA%8E%E5%88%86%E5%B8%83%E9%94%81%E7%9A%84%E5%A4%9A%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/","excerpt":"在很多场景中，我们为了保证数据的最终一致性，需要很多的技术方案来支持，比如分布式事务、分布式锁等。有的时候，我们需要保证一个方法在同一时间内只能被一个线程执行。在单机环境中，JAVA中其实提供很多并发处理相关的API，但是这些api在分布式场景中就无能为力了。也就是说单纯的java Api并不能提供分布式锁的能力。所以针对分布式锁的实现目前有多种方案 比较常见的有以下几种方案:","text":"在很多场景中，我们为了保证数据的最终一致性，需要很多的技术方案来支持，比如分布式事务、分布式锁等。有的时候，我们需要保证一个方法在同一时间内只能被一个线程执行。在单机环境中，JAVA中其实提供很多并发处理相关的API，但是这些api在分布式场景中就无能为力了。也就是说单纯的java Api并不能提供分布式锁的能力。所以针对分布式锁的实现目前有多种方案 比较常见的有以下几种方案: 1、基于数据库实现的分布式锁 2、基于缓存实现分布式锁（常见） 3、基于zookeeper实现分布式锁（常见） 4、基于文件的分布式锁 详谈 基于数据库表这是相对比较简单的一种方式，直接创建一张锁表，然后通过操作该表的数据来实现。当我们要锁住某个方法或者资源的时候，我们就在该表中增加一条记录，想要释放锁的时候就删除该记录。 表结构如下: 1234567891011create table &#39;methodLock&#39; ( &#39;id&#39; int(11) not null auto_increment comment &#39;主键&#39;, &#39;method_name&#39; vachar(64) not null comment &#39;锁定的方法名&#39;， &#39;desc&#39; varchar(1024) not null default &#39;备注信息&#39;， &#39;update_time&#39; &#39;保存数据时间，自动生成&#39;) 锁住方法是，执行sql： 1insert into methodLock(method_name,desc) values (&#39;method_name&#39;,&#39;desc&#39;) 对 method_name 字段做唯一性约束，如果有多个请求提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以任务操作成功的那个县城获得了该方法的锁，可以执行方法体内容。 方法执行完，释放锁，执行以下sql， 1delete from methodLock where method_name &#x3D; &#39;method_name&#39; 弊端: 1、这把锁强依赖数据库的可用性，数据库是一个单点，，数据库一旦挂掉，导致业务系统不可用 2、这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法获得该锁 3、这把只能是非阻塞的，因为数据的insert操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，想再次获得所就要再次出发获得锁操作 解决: 1、可搞两个数据库，数据库之前双向同步，一旦挂掉快速切换到备库上 2、没失效时间？可以做个定时任务，每隔一定时间，清理超时数据 3、非阻塞？ 可以做个while 循环，直到insert成功在返回成功。 基于数据库排他锁我们还用刚刚创建的那张数据库表。可以通过数据库的排他锁来实现分布式锁。基于MySql的InnoDB引擎，可以使用以下方法来实现加锁操作： 12345678910111213141516171819202122232425public boolean lock() &#123; connection.setAutoCommit(false); while(true) &#123; try &#123; result &#x3D; select * from methodLock where method_name &#x3D; xxx for update; if(result &#x3D; null) &#123; return true; &#125; &#125; catch (Exception e) &#123;&#125; sleep(1000); &#125; return false;&#125; 在查询语句后面添加 for update， 数据库在查询过程中给数据库表增加排它锁（这里再多提一句，InnoDB引擎在加锁的时候，只有通过索引进行检索的时候才会使用行级锁，否则会使用表级锁。这里我们希望使用行级锁，就要给method_name添加索引，值得注意的是，这个索引一定要创建成唯一索引，否则会出现多个重载方法之间无法同时被访问的问题。重载方法的话建议把参数类型也加上。） 当某条记录被加上排它锁，其他线程无法再在该记录上增加排它锁 我们可以任务获得排它锁的线程既可以获得分布式锁，当获得所之后，可以执行方法的业务逻辑，执行完方法之后，再通过以下方法解锁 12345public void unlock() &#123; connecion.commit();&#125; 通过以上操作来释放锁。 比较: 相对于以上的方法，解决了无法释放锁和阻塞锁的问题 阻塞锁？ for update 语句在执行成功之后立即返回，在执行失败时一直处于阻塞状态，直到成功 锁定之后服务宕机，无法释放？使用这种方式，服务宕机之后数据库会自己把锁释放掉。 注意点: 1、这里有个问题，虽然我们对 method_name 使用了唯一索引，并且显示的使用了for update 是使用行级锁。但是mysql 会对查询进行优化，几遍在条件中使用了索引字段，但是否使用索引来检索数据是由mysql 通过判断不同执行计划的代价来决定，如果mysql 认为全表扫效率更高。比如对一些很小的表，他就不会使用索引了。这种情况下 innodb 将使用表锁，而不是行锁，若果发生这种情况就悲剧了。。。对于for update 的用法下期会想讲！https://www.cnblogs.com/wangshiwen/p/9837408.html 2、当我们使用排它锁方法进行分布式锁的时候，那么一个排它锁如果长时间不提交的话，就会占用数据库连接，一旦类似的连接变多了，就可能把数据库连接池撑爆。 总结: 以上两种数据的分布式锁方式，都是依赖数据库的一张表。 通过数据库实现的分布式锁的优点：直接借助数据库，容易理解 缺点:存在各种各样的问题，需要各种方法来解决，导致整个方法变得非常复杂 操作数据库需要一定的开销，性能需要考虑。 使用数据库的行级锁的时候并不可靠，尤其当锁表并不大的时候 基于缓存实现分布式锁相对基于数据库实现的分布式锁，基于缓存的分布式锁性能方面相对会好一些。 基于Zookeeper实现分布式锁未完待续…","categories":[],"tags":[{"name":"分布式锁","slug":"分布式锁","permalink":"http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"}]},{"title":"分布式事务解决方案","slug":"分布式事务解决方案","date":"2019-08-23T06:16:45.000Z","updated":"2020-09-06T06:24:31.586Z","comments":true,"path":"2019/08/23/分布式事务解决方案/","link":"","permalink":"http://example.com/2019/08/23/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","excerpt":"","text":"开源方案tcc-transaction:https://github.com/changmingxie/tcc-transactionEasyTransacion: https://github.com/QNJR-GROUP/EasyTransactionLCN: https://github.com/codingapi/tx-lcn http://www.txlcn.org/zh-cn/Raincat: https://github.com/Dromara/Raincathmily: https://github.com/Dromara/hmilymyth: https://github.com/Dromara/myth","categories":[],"tags":[{"name":"分布式事务","slug":"分布式事务","permalink":"http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"},{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"http://example.com/tags/Spring-Cloud/"}]},{"title":"Mysql事务隔离级别","slug":"Mysql事务隔离级别","date":"2019-08-23T06:14:16.000Z","updated":"2020-09-06T06:25:03.140Z","comments":true,"path":"2019/08/23/Mysql事务隔离级别/","link":"","permalink":"http://example.com/2019/08/23/Mysql%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/","excerpt":"数据库事务的隔离级别有四种分别是Read uncommitted 、Read committed 、Repeatable read 、Serializable","text":"数据库事务的隔离级别有四种分别是Read uncommitted 、Read committed 、Repeatable read 、Serializable 1、Read uncommitted读未提交 顾名思义，就是一个事务可以读取另一个未提交事务的数据 2、Read committed读提交，顾名思义，就是一个事务要等另外一个事务提交后才能读取到数据 3、Repeatable read重复读，可重复读就是一个事务只能读到另一个事务修改的已提交了事务的数据，但是第一次读取的数据，即使别的事务修改的这个值，这个事务再读取这条数据的时候还是和第一次获取的一样，不会随着别的事务的修改而改变。这和已提交读的区别就在于，它重复读取的值是不变的。所以取了个贴切的名字叫可重复读 4、Serializable序列化 Serializable 是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免藏独、不可重复读与幻读。但是这种事务隔离级别效率低，比较好数据库性能，一般不使用 本文借鉴 : http://www.zsythink.net/archives/1233/ https://baijiahao.baidu.com/s?id=1629344395894429251&amp;wfr=spider&amp;for=pc","categories":[],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://example.com/tags/Mysql/"},{"name":"事务隔离级别","slug":"事务隔离级别","permalink":"http://example.com/tags/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"}]},{"title":"浅谈 @EnableConfigurationProperties 注解","slug":"浅谈-EnableConfigurationProperties-注解","date":"2019-01-05T06:17:40.000Z","updated":"2020-09-06T06:23:21.493Z","comments":true,"path":"2019/01/05/浅谈-EnableConfigurationProperties-注解/","link":"","permalink":"http://example.com/2019/01/05/%E6%B5%85%E8%B0%88-EnableConfigurationProperties-%E6%B3%A8%E8%A7%A3/","excerpt":"先说作用:@EnableConfigurationProperties注解的作用是：使使用 @ConfigurationProperties 注解的类生效。 详解:","text":"先说作用:@EnableConfigurationProperties注解的作用是：使使用 @ConfigurationProperties 注解的类生效。 详解: 要想 @ConfigurationProperties 注解的类让生效, 有两种方式 第一种如果一个配置类只配置@ConfigurationProperties注解，而没有使用@Component，那么在IOC容器中是获取不到properties 配置文件转化的bean。说白了 @EnableConfigurationProperties 相当于把使用 @ConfigurationProperties 的类进行了一次注入。 第二种不使用 @EnableConfigurationProperties 进行注册，使用 @Component 注册 PS:spring boot版本2.2.0.M5起 @ConfigurationProperties与@Component不能同时存在，否则会出现2次注入，也就是说，必须配合@EnableConfigurationProperties 使用 待验证…","categories":[],"tags":[{"name":"springboot","slug":"springboot","permalink":"http://example.com/tags/springboot/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]}],"categories":[],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://example.com/tags/HTTP/"},{"name":"协议","slug":"协议","permalink":"http://example.com/tags/%E5%8D%8F%E8%AE%AE/"},{"name":"网络传输","slug":"网络传输","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"Spring","slug":"Spring","permalink":"http://example.com/tags/Spring/"},{"name":"基础","slug":"基础","permalink":"http://example.com/tags/%E5%9F%BA%E7%A1%80/"},{"name":"分布式锁","slug":"分布式锁","permalink":"http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"},{"name":"分布式事务","slug":"分布式事务","permalink":"http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"},{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"http://example.com/tags/Spring-Cloud/"},{"name":"Mysql","slug":"Mysql","permalink":"http://example.com/tags/Mysql/"},{"name":"事务隔离级别","slug":"事务隔离级别","permalink":"http://example.com/tags/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"},{"name":"springboot","slug":"springboot","permalink":"http://example.com/tags/springboot/"}]}